# ✅ STUDY PLAN — AI Code Reviewer + LeetCode + Systems Thinking

## WEEKLY PLAN STRUCTURE

Each week:
3 Core Study Sessions: Focus on new topics.
2 Practice Sessions: Apply what you've learned via LeetCode + mock problems.
1 Review & Optimize: Refactor, write documentation, discuss root causes.
Follow the Troubleshooting + Problem Solving frameworks as you code.

## WEEK 1–2: Arrays & Sliding Windows

### Topics:

Array traversal
Prefix sums
Two Pointers
Sliding Window
Time Complexity (O(1), O(n), O(n²))

### LeetCode Focus:

✅ Best Time to Buy and Sell Stock II
⏳ Jump Game II
⏳ Minimum Size Subarray Sum
⏳ Longest Substring Without Repeating Characters
⏳ Container With Most Water

### Concepts:

Explain edge cases (negative numbers, empty arrays)
Ask constraint clarifying questions (time/space bounds)
Optimize brute-force → greedy/DP

### Problem Solving:

Document constraints
Clarify edge behavior
Write helper functions with docstrings
Add validations (e.g., input.length > 0)
Write unit test for sliding window boundaries

## WEEK 3–4: HashMaps & Sets

Topics:

Hash table design

Set operations

Frequency counting

Detecting cycles or duplicates

LeetCode Focus:

⏳ Product of Array Except Self

⏳ Group Anagrams

⏳ Two Sum

⏳ Contains Duplicate II

⏳ Longest Consecutive Sequence

⏳ Ransom Note

Concepts:

Time-space tradeoffs

Choosing between arrays vs maps

Hash collisions & chaining (discuss in interview)

Practice:

Implement your own hash map briefly

Describe collisions and probing strategies

Add runbook comments for O(n) logic

## WEEK 5–6: Strings & Substring Patterns

Topics:

String traversal

Character maps

Validity checks (anagrams, palindromes)

LeetCode Focus:

⏳ Reverse Words in a String

⏳ Longest Common Prefix

⏳ Is Subsequence

⏳ Valid Palindrome

⏳ Minimum Window Substring (hard)

Practice:

Build string utilities module

Document helper methods (strip, reverse, etc.)

Add test cases for punctuation, whitespace, edge cases

## WEEK 7–8: Stacks & Intervals

Topics:

Stack usage (bracket matching, expression evaluation)

Interval merging and sorting

LeetCode Focus:

⏳ Valid Parentheses

⏳ Simplify Path

⏳ Merge Intervals

⏳ Insert Interval

⏳ Min Stack

Practice:

Use stack visualizations

Diagram step-by-step operations

Document edge case conditions in stack logic

## WEEK 9–10: Binary Trees (DFS/BFS)

Topics:

Binary tree traversal (inorder, preorder, postorder)

Recursive vs iterative

BFS/DFS strategies

LeetCode Focus:

⏳ Invert Binary Tree

⏳ Symmetric Tree

⏳ Maximum Depth of Binary Tree

⏳ Construct Binary Tree from Preorder + Inorder

⏳ Path Sum

Practice:

Recap recursive tree traversal

Show time complexity per traversal type

Write debug logs for each visit step

## WEEK 11–12: Graphs & BFS/DFS

Topics:

Graph representation (adjacency list/matrix)

BFS traversal, visited set

Topological sort

LeetCode Focus:

⏳ Number of Islands

⏳ Clone Graph

⏳ Course Schedule

⏳ Evaluate Division

⏳ Word Ladder

Practice:

Mock problems on whiteboard

Explain recursion stack vs queue for BFS

Document visit order + decision branches

## WEEK 13–14: DP & 1D Patterns

Topics:

Memoization & Tabulation

State definition

Overlapping subproblems

LeetCode Focus:

⏳ Climbing Stairs

⏳ House Robber

⏳ Longest Increasing Subsequence

⏳ Word Break

⏳ Coin Change

Practice:

Convert brute force to memo

Write decision tree for recursive state

Use @lru_cache in Python for experiments
